<?xml version="1.0" encoding="utf-8"?><testsuite errors="2" failures="0" name="" skips="0" tests="0" time="0.298"><testcase classname="scripts.LoginTest.CheckLoginExample" name="test_login_show_gear" time="0.0108699798584"><error message="test setup failure">self = &lt;LoginTest.CheckLoginExample object at 0x10663e210&gt;
method = &lt;bound method CheckLoginExample.test_login_show_gear of &lt;LoginTest.CheckLoginExample object at 0x10663e210&gt;&gt;

    def setup_method(self, method):
        &quot;&quot;&quot;
            Parent class of all script classes used for custom asserts (usually &apos;soft&apos; asserts) and shared fixture setup
            and teardown
            &quot;&quot;&quot;
        self.cf = saunter.ConfigWrapper.ConfigWrapper().config
        self.config = self.cf
    
        self.current_method_name = method.__name__
    
        browser = self.cf.get(&quot;Selenium&quot;, &quot;browser&quot;)
        if browser[0] == &quot;*&quot;:
            browser = browser[1:]
    
        profile = None
        if browser == &apos;firefox&apos;:
            if self.cf.has_option(&quot;Selenium&quot;, &quot;profile-%s&quot; % sys.platform):
                profile_path = os.path.join(self.cf.get(&quot;Saunter&quot;, &quot;base&quot;), &apos;support&apos;, &apos;profiles&apos;, self.cf.get(&quot;Selenium&quot;, &quot;profile-%s&quot; % sys.platform))
            elif self.cf.has_option(&quot;Selenium&quot;, &quot;profile&quot;):
                profile_path = os.path.join(self.cf.get(&quot;Saunter&quot;, &quot;base&quot;), &apos;support&apos;, &apos;profiles&apos;, self.cf.get(&quot;Selenium&quot;, &quot;profile&quot;))
            else:
                profile_path = None
    
            if profile_path:
                if os.path.isdir(profile_path):
                    profile = FirefoxProfile(profile_path)
                else:
                    raise ProfileNotFound(&quot;Profile not found at %s&quot; % profile_path)
    
        if self.cf.getboolean(&quot;SauceLabs&quot;, &quot;ondemand&quot;):
            desired_capabilities = {
                &quot;platform&quot;: self.cf.get(&quot;SauceLabs&quot;, &quot;os&quot;),
                &quot;browserName&quot;: self.cf.get(&quot;SauceLabs&quot;, &quot;browser&quot;),
                &quot;version&quot;: self.cf.get(&quot;SauceLabs&quot;, &quot;browser_version&quot;),
                &quot;name&quot;: method.__name__
            }
            if desired_capabilities[&quot;browserName&quot;][0] == &quot;*&quot;:
                desired_capabilities[&quot;browserName&quot;] = desired_capabilities[&quot;browserName&quot;][1:]
            if desired_capabilities[&quot;platform&quot;] in os_map:
                desired_capabilities[&quot;platform&quot;] = os_map[desired_capabilities[&quot;platform&quot;]]
    
            if self.cf.has_option(&quot;SauceLabs&quot;, &quot;selenium_version&quot;):
                desired_capabilities[&apos;selenium-version&apos;] = self.cf.get(&apos;SauceLabs&apos;, &apos;selenium_version&apos;)
    
            command_executor = &quot;http://%s:%s@ondemand.saucelabs.com:80/wd/hub&quot; % (self.cf.get(&quot;SauceLabs&quot;, &quot;username&quot;), self.cf.get(&quot;SauceLabs&quot;, &quot;key&quot;))
        else:
    
            if browser == &quot;chrome&quot;:
                os.environ[&quot;webdriver.chrome.driver&quot;] = self.cf.get(&quot;Selenium&quot;, &quot;chromedriver_path&quot;)
            desired_capabilities = capabilities_map[browser]
            if self.cf.has_section(&quot;Proxy&quot;) \
                and self.cf.has_option(&quot;Proxy&quot;, &quot;proxy_url&quot;) \
                and (self.cf.has_option(&quot;Proxy&quot;, &quot;browsermob&quot;) and self.cf.getboolean(&quot;Proxy&quot;, &quot;browsermob&quot;)):
                from browsermobproxy import Client
                self.client = Client(self.cf.get(&quot;Proxy&quot;, &quot;proxy_url&quot;))
                self.client.add_to_webdriver_capabilities(desired_capabilities)
            if self.cf.has_section(&quot;Grid&quot;):
                if self.cf.getboolean(&quot;Grid&quot;, &quot;use_grid&quot;) and self.cf.get(&quot;Grid&quot;, &quot;type&quot;) == &quot;selenium&quot;:
                    if self.cf.has_option(&quot;Grid&quot;, &quot;platform&quot;):
                        desired_capabilities[&quot;platform&quot;] = self.cf.get(&quot;Grid&quot;, &quot;platform&quot;).upper()
                    if self.cf.has_option(&quot;Grid&quot;, &quot;version&quot;):
                        desired_capabilities[&quot;version&quot;] = str(self.cf.get(&quot;Grid&quot;, &quot;browser_version&quot;))
    
            command_executor = &quot;http://%s:%s/wd/hub&quot; % (self.cf.get(&quot;Selenium&quot;, &quot;server_host&quot;), self.cf.get(&quot;Selenium&quot;, &quot;server_port&quot;))
    
&gt;       self.driver = WebDriver(desired_capabilities = desired_capabilities, command_executor = command_executor, browser_profile=profile)

../pysaunter_examples_env/lib/python2.7/site-packages/saunter/testcase/webdriver.py:151: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;tailored.webdriver.WebDriver object at 0x10663e8d0&gt;
kwargs = {&apos;browser_profile&apos;: None, &apos;command_executor&apos;: &apos;http://localhost:4444/wd/hub&apos;, &apos;desired_capabilities&apos;: {&apos;browserName&apos;: &apos;firefox&apos;, &apos;javascriptEnabled&apos;: True, &apos;platform&apos;: &apos;ANY&apos;, &apos;version&apos;: &apos;&apos;}}

    def __init__(self, **kwargs):
&gt;       super(WebDriver, self).__init__(**kwargs)

modules/tailored/webdriver.py:13: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;tailored.webdriver.WebDriver object at 0x10663e8d0&gt;
kwargs = {&apos;browser_profile&apos;: None, &apos;command_executor&apos;: &apos;http://localhost:4444/wd/hub&apos;, &apos;desired_capabilities&apos;: {&apos;browserName&apos;: &apos;firefox&apos;, &apos;javascriptEnabled&apos;: True, &apos;platform&apos;: &apos;ANY&apos;, &apos;version&apos;: &apos;&apos;}}

    def __init__(self, **kwargs):
&gt;       super(SaunterWebDriver, self).__init__(**kwargs)

../pysaunter_examples_env/lib/python2.7/site-packages/saunter/SaunterWebDriver.py:22: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;tailored.webdriver.WebDriver object at 0x10663e8d0&gt;, command_executor = &apos;http://localhost:4444/wd/hub&apos;
desired_capabilities = {&apos;browserName&apos;: &apos;firefox&apos;, &apos;javascriptEnabled&apos;: True, &apos;platform&apos;: &apos;ANY&apos;, &apos;version&apos;: &apos;&apos;}, browser_profile = None, proxy = None

    def __init__(self, command_executor=&apos;http://127.0.0.1:4444/wd/hub&apos;,
        desired_capabilities=None, browser_profile=None, proxy=None):
        &quot;&quot;&quot;
            Create a new driver that will issue commands using the wire protocol.
    
            :Args:
             - command_executor - Either a command.CommandExecutor object or a string that specifies the URL of a remote server to send commands to.
             - desired_capabilities - Dictionary holding predefined values for starting a browser
             - browser_profile - A selenium.webdriver.firefox.firefox_profile.FirefoxProfile object.  Only used if Firefox is requested.
            &quot;&quot;&quot;
        if desired_capabilities is None:
            raise WebDriverException(&quot;Desired Capabilities can&apos;t be None&quot;)
        if not isinstance(desired_capabilities, dict):
            raise WebDriverException(&quot;Desired Capabilities must be a dictionary&quot;)
        if proxy is not None:
            proxy.add_to_capabilities(desired_capabilities)
        self.command_executor = command_executor
        if type(self.command_executor) is bytes or type(self.command_executor) is str:
            self.command_executor = RemoteConnection(command_executor)
        self._is_remote = True
        self.session_id = None
        self.capabilities = {}
        self.error_handler = ErrorHandler()
        self.start_client()
&gt;       self.start_session(desired_capabilities, browser_profile)

../pysaunter_examples_env/lib/python2.7/site-packages/selenium/webdriver/remote/webdriver.py:72: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;tailored.webdriver.WebDriver object at 0x10663e8d0&gt;
desired_capabilities = {&apos;browserName&apos;: &apos;firefox&apos;, &apos;javascriptEnabled&apos;: True, &apos;platform&apos;: &apos;ANY&apos;, &apos;version&apos;: &apos;&apos;}, browser_profile = None

    def start_session(self, desired_capabilities, browser_profile=None):
        &quot;&quot;&quot;
            Creates a new session with the desired capabilities.
    
            :Args:
             - browser_name - The name of the browser to request.
             - version - Which browser version to request.
             - platform - Which platform to request the browser on.
             - javascript_enabled - Whether the new session should support JavaScript.
             - browser_profile - A selenium.webdriver.firefox.firefox_profile.FirefoxProfile object. Only used if Firefox is requested.
            &quot;&quot;&quot;
        if browser_profile:
            desired_capabilities[&apos;firefox_profile&apos;] = browser_profile.encoded
        response = self.execute(Command.NEW_SESSION, {
&gt;           &apos;desiredCapabilities&apos;: desired_capabilities,
        })

../pysaunter_examples_env/lib/python2.7/site-packages/selenium/webdriver/remote/webdriver.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;tailored.webdriver.WebDriver object at 0x10663e8d0&gt;, driver_command = &apos;newSession&apos;
params = {&apos;desiredCapabilities&apos;: {&apos;browserName&apos;: &apos;firefox&apos;, &apos;javascriptEnabled&apos;: True, &apos;platform&apos;: &apos;ANY&apos;, &apos;version&apos;: &apos;&apos;}, &apos;sessionId&apos;: None}

    def execute(self, driver_command, params=None):
        &quot;&quot;&quot;
            Sends a command to be executed by a command.CommandExecutor.
    
            :Args:
             - driver_command: The name of the command to execute as a string.
             - params: A dictionary of named parameters to send with the command.
    
            :Returns:
              The command&apos;s JSON response loaded into a dictionary object.
            &quot;&quot;&quot;
        if not params:
            params = {&apos;sessionId&apos;: self.session_id}
        elif &apos;sessionId&apos; not in params:
            params[&apos;sessionId&apos;] = self.session_id
    
        params = self._wrap_value(params)
&gt;       response = self.command_executor.execute(driver_command, params)

../pysaunter_examples_env/lib/python2.7/site-packages/selenium/webdriver/remote/webdriver.py:163: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;selenium.webdriver.remote.remote_connection.RemoteConnection object at 0x10663ed90&gt;, command = &apos;newSession&apos;
params = {&apos;desiredCapabilities&apos;: {&apos;browserName&apos;: &apos;firefox&apos;, &apos;javascriptEnabled&apos;: True, &apos;platform&apos;: &apos;ANY&apos;, &apos;version&apos;: &apos;&apos;}, &apos;sessionId&apos;: None}

    def execute(self, command, params):
        &quot;&quot;&quot;
            Send a command to the remote server.
    
            Any path subtitutions required for the URL mapped to the command should be
            included in the command parameters.
    
            :Args:
             - command - A string specifying the command to execute.
             - params - A dictionary of named parameters to send with the command as
               its JSON payload.
            &quot;&quot;&quot;
        command_info = self._commands[command]
        assert command_info is not None, &apos;Unrecognised command %s&apos; % command
        data = utils.dump_json(params)
        path = string.Template(command_info[1]).substitute(params)
        url = &apos;%s%s&apos; % (self._url, path)
&gt;       return self._request(url, method=command_info[0], data=data)

../pysaunter_examples_env/lib/python2.7/site-packages/selenium/webdriver/remote/remote_connection.py:353: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;selenium.webdriver.remote.remote_connection.RemoteConnection object at 0x10663ed90&gt;, url = &apos;http://127.0.0.1:4444/wd/hub/session&apos;
data = &apos;{&quot;sessionId&quot;: null, &quot;desiredCapabilities&quot;: {&quot;platform&quot;: &quot;ANY&quot;, &quot;browserName&quot;: &quot;firefox&quot;, &quot;version&quot;: &quot;&quot;, &quot;javascriptEnabled&quot;: true}}&apos;, method = &apos;POST&apos;

    def _request(self, url, data=None, method=None):
        &quot;&quot;&quot;
            Send an HTTP request to the remote server.
    
            :Args:
             - method - A string for the HTTP method to send the request with.
             - url - The URL to send the request to.
             - body - The message body to send.
    
            :Returns:
              A dictionary with the server&apos;s parsed JSON response.
            &quot;&quot;&quot;
        LOGGER.debug(&apos;%s %s %s&apos; % (method, url, data))
    
        parsed_url = parse.urlparse(url)
        password_manager = None
        if parsed_url.username:
            netloc = parsed_url.hostname
            if parsed_url.port:
                netloc += &quot;:%s&quot; % parsed_url.port
            cleaned_url = parse.urlunparse((parsed_url.scheme,
                                               netloc,
                                               parsed_url.path,
                                               parsed_url.params,
                                               parsed_url.query,
                                               parsed_url.fragment))
            password_manager = url_request.HTTPPasswordMgrWithDefaultRealm()
            password_manager.add_password(None,
                                          &quot;%s://%s&quot; % (parsed_url.scheme, netloc),
                                          parsed_url.username,
                                          parsed_url.password)
            request = Request(cleaned_url, data=data.encode(&apos;utf-8&apos;), method=method)
        else:
            request = Request(url, data=data.encode(&apos;utf-8&apos;), method=method)
    
        request.add_header(&apos;Accept&apos;, &apos;application/json&apos;)
        request.add_header(&apos;Content-Type&apos;, &apos;application/json;charset=UTF-8&apos;)
    
        if password_manager:
            opener = url_request.build_opener(url_request.HTTPRedirectHandler(),
                                          HttpErrorHandler(),
                                          url_request.HTTPBasicAuthHandler(password_manager))
        else:
            opener = url_request.build_opener(url_request.HTTPRedirectHandler(),
                                          HttpErrorHandler())
&gt;       response = opener.open(request)

../pysaunter_examples_env/lib/python2.7/site-packages/selenium/webdriver/remote/remote_connection.py:400: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib2.OpenerDirector instance at 0x106359b48&gt;, fullurl = &lt;selenium.webdriver.remote.remote_connection.Request instance at 0x1063630e0&gt;, data = None
timeout = &lt;object object at 0x105a69200&gt;

    def open(self, fullurl, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT):
        # accept a URL or a Request object
        if isinstance(fullurl, basestring):
            req = Request(fullurl, data)
        else:
            req = fullurl
            if data is not None:
                req.add_data(data)
    
        req.timeout = timeout
        protocol = req.get_type()
    
        # pre-process request
        meth_name = protocol+&quot;_request&quot;
        for processor in self.process_request.get(protocol, []):
            meth = getattr(processor, meth_name)
            req = meth(req)
    
&gt;       response = self._open(req, data)

/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:394: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib2.OpenerDirector instance at 0x106359b48&gt;, req = &lt;selenium.webdriver.remote.remote_connection.Request instance at 0x1063630e0&gt;, data = None

    def _open(self, req, data=None):
        result = self._call_chain(self.handle_open, &apos;default&apos;,
                                  &apos;default_open&apos;, req)
        if result:
            return result
    
        protocol = req.get_type()
        result = self._call_chain(self.handle_open, protocol, protocol +
&gt;                                 &apos;_open&apos;, req)

/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:412: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib2.OpenerDirector instance at 0x106359b48&gt;
chain = {&apos;file&apos;: [&lt;urllib2.FileHandler instance at 0x1063597a0&gt;], &apos;ftp&apos;: [&lt;urllib2.FTPHandler instance at 0x106359c20&gt;], &apos;http&apos;: [&lt;urllib2.HTTPHandler instance at 0x106359128&gt;], &apos;https&apos;: [&lt;urllib2.HTTPSHandler instance at 0x1064c6e18&gt;], ...}
kind = &apos;http&apos;, meth_name = &apos;http_open&apos;, args = (&lt;selenium.webdriver.remote.remote_connection.Request instance at 0x1063630e0&gt;,)
handlers = [&lt;urllib2.HTTPHandler instance at 0x106359128&gt;], handler = &lt;urllib2.HTTPHandler instance at 0x106359128&gt;
func = &lt;bound method HTTPHandler.http_open of &lt;urllib2.HTTPHandler instance at 0x106359128&gt;&gt;

    def _call_chain(self, chain, kind, meth_name, *args):
        # Handlers raise an exception if no one else should try to handle
        # the request, or return None if they can&apos;t but another handler
        # could.  Otherwise, they return the response.
        handlers = chain.get(kind, ())
        for handler in handlers:
            func = getattr(handler, meth_name)
    
&gt;           result = func(*args)

/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:372: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib2.HTTPHandler instance at 0x106359128&gt;, req = &lt;selenium.webdriver.remote.remote_connection.Request instance at 0x1063630e0&gt;

    def http_open(self, req):
&gt;       return self.do_open(httplib.HTTPConnection, req)

/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:1199: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;urllib2.HTTPHandler instance at 0x106359128&gt;, http_class = &lt;class httplib.HTTPConnection at 0x10614eae0&gt;
req = &lt;selenium.webdriver.remote.remote_connection.Request instance at 0x1063630e0&gt;

    def do_open(self, http_class, req):
        &quot;&quot;&quot;Return an addinfourl object for the request, using http_class.
    
            http_class must implement the HTTPConnection API from httplib.
            The addinfourl return value is a file-like object.  It also
            has methods and attributes including:
                - info(): return a mimetools.Message object for the headers
                - geturl(): return the original request URL
                - code: HTTP status code
            &quot;&quot;&quot;
        host = req.get_host()
        if not host:
            raise URLError(&apos;no host given&apos;)
    
        h = http_class(host, timeout=req.timeout) # will parse host:port
        h.set_debuglevel(self._debuglevel)
    
        headers = dict(req.unredirected_hdrs)
        headers.update(dict((k, v) for k, v in req.headers.items()
                            if k not in headers))
    
        # We want to make an HTTP/1.1 request, but the addinfourl
        # class isn&apos;t prepared to deal with a persistent connection.
        # It will try to read all remaining data from the socket,
        # which will block while the server waits for the next request.
        # So make sure the connection gets closed after the (only)
        # request.
        headers[&quot;Connection&quot;] = &quot;close&quot;
        headers = dict(
            (name.title(), val) for name, val in headers.items())
    
        if req._tunnel_host:
            tunnel_headers = {}
            proxy_auth_hdr = &quot;Proxy-Authorization&quot;
            if proxy_auth_hdr in headers:
                tunnel_headers[proxy_auth_hdr] = headers[proxy_auth_hdr]
                # Proxy-Authorization should not be sent to origin
                # server.
                del headers[proxy_auth_hdr]
            h.set_tunnel(req._tunnel_host, headers=tunnel_headers)
    
        try:
            h.request(req.get_method(), req.get_selector(), req.data, headers)
            try:
                r = h.getresponse(buffering=True)
            except TypeError: #buffering kw not supported
                r = h.getresponse()
        except socket.error, err: # XXX what error?
&gt;           raise URLError(err)
E           URLError: &lt;urlopen error [Errno 61] Connection refused&gt;

/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py:1174: URLError</error></testcase><testcase classname="scripts.LoginTest.CheckLoginExample" name="test_login_show_gear" time="0.000484943389893"><error message="test setup failure">__multicall__ = &lt;MultiCall 0 results, 0 meths, kwargs={&apos;item&apos;: &lt;Function &apos;test_login_show_gear&apos;&gt;, &apos;nextitem&apos;: None}&gt;, item = &lt;Function &apos;test_login_show_gear&apos;&gt;

    def pytest_runtest_teardown(__multicall__, item):
&gt;       __multicall__.execute()

conftest.py:52: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;MultiCall 0 results, 0 meths, kwargs={&apos;item&apos;: &lt;Function &apos;test_login_show_gear&apos;&gt;, &apos;nextitem&apos;: None}&gt;

    def execute(self):
        while self.methods:
            method = self.methods.pop()
            kwargs = self.getkwargs(method)
&gt;           res = method(**kwargs)

../pysaunter_examples_env/lib/python2.7/site-packages/_pytest/core.py:370: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

item = &lt;Function &apos;test_login_show_gear&apos;&gt;, nextitem = None

    def pytest_runtest_teardown(item, nextitem):
&gt;       item.session._setupstate.teardown_exact(item, nextitem)

../pysaunter_examples_env/lib/python2.7/site-packages/_pytest/runner.py:89: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;_pytest.runner.SetupState object at 0x10652eed0&gt;, item = &lt;Function &apos;test_login_show_gear&apos;&gt;, nextitem = None

    def teardown_exact(self, item, nextitem):
        needed_collectors = nextitem and nextitem.listchain() or []
&gt;       self._teardown_towards(needed_collectors)

../pysaunter_examples_env/lib/python2.7/site-packages/_pytest/runner.py:340: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;_pytest.runner.SetupState object at 0x10652eed0&gt;, needed_collectors = []

    def _teardown_towards(self, needed_collectors):
        while self.stack:
            if self.stack == needed_collectors[:len(self.stack)]:
                break
&gt;           self._pop_and_teardown()

../pysaunter_examples_env/lib/python2.7/site-packages/_pytest/runner.py:346: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;_pytest.runner.SetupState object at 0x10652eed0&gt;

    def _pop_and_teardown(self):
        colitem = self.stack.pop()
&gt;       self._teardown_with_finalization(colitem)

../pysaunter_examples_env/lib/python2.7/site-packages/_pytest/runner.py:315: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;_pytest.runner.SetupState object at 0x10652eed0&gt;, colitem = &lt;Function &apos;test_login_show_gear&apos;&gt;

    def _teardown_with_finalization(self, colitem):
        self._callfinalizers(colitem)
        if hasattr(colitem, &quot;teardown&quot;):
&gt;           colitem.teardown()

../pysaunter_examples_env/lib/python2.7/site-packages/_pytest/runner.py:326: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;Function &apos;test_login_show_gear&apos;&gt;

    def teardown(self):
        &quot;&quot;&quot; perform teardown for this test function. &quot;&quot;&quot;
        if inspect.ismethod(self.obj):
            name = &apos;teardown_method&apos;
        else:
            name = &apos;teardown_function&apos;
        obj = self.parent.obj
        teardown_func_or_meth = xunitsetup(obj, name)
        if teardown_func_or_meth is not None:
&gt;           teardown_func_or_meth(self.obj)

../pysaunter_examples_env/lib/python2.7/site-packages/_pytest/python.py:461: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;LoginTest.CheckLoginExample object at 0x10663e210&gt;
method = &lt;bound method CheckLoginExample.test_login_show_gear of &lt;LoginTest.CheckLoginExample object at 0x10663e210&gt;&gt;

    def teardown_method(self, method):
        &quot;&quot;&quot;
            Default teardown method for all scripts. If run through Sauce Labs OnDemand, the job name, status and tags
            are updated. Also the video and server log are downloaded if so configured.
            &quot;&quot;&quot;
        if hasattr(self, &quot;config&quot;) and not self.config.getboolean(&quot;SauceLabs&quot;, &quot;ondemand&quot;):
&gt;           self.take_named_screenshot(&quot;final&quot;)

../pysaunter_examples_env/lib/python2.7/site-packages/saunter/testcase/webdriver.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;LoginTest.CheckLoginExample object at 0x10663e210&gt;, name = &apos;final&apos;

    def take_named_screenshot(self, name):
        method_dir = self._screenshot_prep_dirs()
    
        image_path = os.path.join(method_dir, str(name) + &quot;.png&quot;)
&gt;       self.driver.get_screenshot_as_file(image_path)
E       AttributeError: &apos;CheckLoginExample&apos; object has no attribute &apos;driver&apos;

../pysaunter_examples_env/lib/python2.7/site-packages/saunter/testcase/webdriver.py:188: AttributeError</error></testcase></testsuite>